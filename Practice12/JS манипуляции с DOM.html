<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <style>
    body {
      font-size: 16px;
      line-height: 22px;
      font-family: "TT Norms Pro","Arial",sans-serif;
      color: #333;
      word-wrap: break-word;
      max-width: 640px;
    }
    h1 {
      font-size: 24px;
    }
    h2 {
      font-size: 18px;
    }


    p{
      margin-bottom: 2em;
    }
    .code {
      background-color: #f8f8f8;
      font-size: 16px;
      font-family: "Ubuntu Mono","Menlo","Monaco","Consolas","Courier New",monospace;
    }

    </style>
  </head>
  <body>


<h1>Конспект «Манипуляции с DOM»
<h2>Коллекции</h2>

<p>Есть несколько способов, чтобы найти сразу несколько элементов на странице. Элементы записываются в структуру, которая называется коллекцией. Коллекции похожи на массив, но ими не являются. При этом к элементам коллекции можно обращаться по индексу и перебирать в цикле for, как и обычные массивы.</p>

<p>Ниже несколько способов получения коллекций:</p>

<p> --element.querySelectorAll() — возвращает все элементы, которые подходят под указанное правило. Эта запись остаётся статичной и изменения в DOM на неё никак не влияют. Можно сказать, что querySelectorAll работает, как любая переменная, в которую мы записали какое-нибудь значение. Пока мы не переопределим переменную, в ней так и будет находиться то значение, которое мы в неё записали, независимо от того, что происходит в коде. Поэтому такая коллекция называется статичной.<br>
 --parentElement.children — вызывается на родительском элементе и собирает все дочерние элементы в динамическую коллекцию. Такие коллекции реагируют на изменения в DOM. Если один из элементов коллекции будет удалён из DOM, то он пропадёт и из коллекции.</p>

<h2>Работа с элементами</h2>

<h3>Удаление элемента</h3>

<p>Удалять элементы со страницы можно разными способами, один из самых простых — вызов метода remove на элементе, который нужно удалить.</p>
<div class="code">
<p>element.remove();</p>
</div>

<p>Метод из примера выше удалит element из DOM.</p>
<h3>Клонирование элемента</h3>

<p>С помощью клонирования мы можем копировать элементы сколько угодно раз и вставлять их в любые места на странице. Для этого существует метод cloneNode. Синтаксис такой:</p>

<div class="code">
<p>element.cloneNode(true); <br>
// Вернёт склонированный элемент со всеми вложенностями</p>

<p>element.cloneNode(false); <br>
// Вернёт склонированный элемент без вложенностей</p>

<p>element.cloneNode(); <br>
// 0_o</p>
</div>
<p>При передаче true в качестве аргумента клонируется сам элемент вместе со всеми вложенностями. Причём клонируются атрибуты, классы и текстовое содержимое всех вложенностей. Такое клонирование называется глубоким.</p>

<p>Если передать методу в качестве аргумента значение false, то будет скопирован сам элемент со своими классами и атрибутами, но без дочерних элементов.</p>

<p>Лучше всегда явно передавать аргумент в cloneNode, чтобы избежать ошибок в работе программ.<p>

<h3>Как получить текст из поля ввода</h3>

<p>Нужно обратиться к свойству поля ввода value. Оно хранит информацию, введённую в поле.</p>
<div class="code">
<p>input.value;</p>
</div>
<p>Результат можно сохранить в переменную и использовать дальше в коде.</p>
<h2>Шаблоны и тег template</h2>

<p>Тег template хранит в себе шаблон для будущих элементов. Он там же, где и вся разметка сайта, только его содержимое не отображается на странице.</p>

<p>Чтобы получить template в JavaScript, можно найти его по идентификатору. Это уникальное название записывают в атрибут id. Такой атрибут можно указывать для разных элементов, главное соблюдать правило — значение атрибута не должно повторяться на одной странице.</p>

<p>Шаблон в разметке:</p>
<div class="code">
<p>&ltbody><br>
 …<br>
 &lttemplate id="text-template"><br>
 &ltp class="text">&lt/p><br>
 &lt/template><br>
&lt/body></p>
</div>
<p>Поиск элемента в JavaScript:</p>
<div class="code">
<p>document.querySelector('#text-template');</p>
</div>
<p>Решётка в параметре querySelector обозначает, что искать надо по id.</p>

<p>Внутри template находится document-fragment или просто фрагмент. Он является хранилищем содержимого тега template. Именно благодаря ему разметка из template не отображается на странице.</p>

<p>Чтобы получить необходимые элементы в шаблоне, надо обратиться к document-fragment, он находится в свойстве content и дальше искать нужные элементы привычными методами поиска.</p>
<div class="code">
<p>&ltbody><br>
…<br>
&lttemplate id="text-template"><br>
 &ltp class="text">&lt/p><br>
&lt/template><br>
&lt/body></p>
</div>
<p>Если мы хотим найти элемент в шаблоне, надо искать так:</p>
<div class="code">
<p>var template = document.querySelector('#text-template');<br>
// Нашли template в документе</p>

<p>var content = template.content;<br>
// Получили содержимое, фрагмент</p>

<p>var text = content.querySelector('.text');<br>
// Нашли нужный шаблон</p>
</div>
<p>Эту запись можно сократить. Например, записать в отдельную переменную контент, а в другую искомый шаблон.</p>
<div class="code">
<p>var textTemplate = document.querySelector('#text-template').content;<br>
var text = textTemplate.querySelector('.text');</p>
</div>
<h2>События</h2>

<p> — <b>change</b> — срабатывает, когда состояние поля ввода меняется. Например, невыбранный чекбокс становится выбранным или наоборот.<br>
 — <b>submit</b> — реагирует на отправку формы. Формы отправляются по умолчанию так же, как при клике по ссылке происходит переход по указанному адресу. Если вам не нужно отправлять форму в каких-то случаях, отмените действие по умолчанию с помощью preventDefault.</p>
 <script src="src/script.js"></script>
 </body>
 </html>
